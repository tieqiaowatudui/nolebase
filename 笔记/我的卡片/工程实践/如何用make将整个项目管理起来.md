使用c语言开发的时候,需要频繁的使用gcc指令对开发出的源代码进行编译并指定编译结果存放的地方.整个构建过程手动太过麻烦,很多时候我们只修改了大量文件中的一小部分,使用指令依然全量重新编译消耗大量时间.
为了实现构建的自动化以及对于目标文件的管理以及各种不同文件之间的依赖关系,引入了构建工具make.
make工具需要在机器上安装make程序.使用的方式是在工程目录空间中添加一个`Makefile`文件.
`Makefile`文件的核心围绕 target,resource,command三者展开.具体的语法如下:

```c
target:resource
	command
```

这其中target是必须有的.而resource和command不适必须的,至少有一个.
构建的核心逻辑就是:资源target依赖于resource,通过command实现依赖资源和target的转变.
> command这里必须使用 `tab`.如果使用四个空格会报错.

# 目标(target)
目标是make构建的结果,这个结果可以作为其他目标的资源的中间目标,也可以是最终的目标,也可以作为触发command执行的一个单位.

# 资源(resource)
资源有两种其他实现,一种是其他的目标,还有一种是当前目录下的文件.

# 命令(command)
命令是对当前当前的资源,以及作为目标的参数输入内容进行执行命令,并且将对应的执行结果输出为目标.其中命令的参数来源有两个,一个是当前的目标资源信息,第二个是从指令中来的.
## 依赖的资源
在命令中，你可以用自动变量获取依赖信息：
- `$@` → 当前目标名称
- `$<` → 第一个依赖
- `$^` → 所有依赖
## 命令行传递参数
可以在命令行中传递参数,这样便于指令进行执行.
例如:
```shell
make run file=sort_quick
```

在makefile中可以通过$(file)进行获取.
```makefile
run:
	./build/$(file)

```

# 依赖
make工具中,管理了目标和资源以及目标之间的依赖关系.对于目标的依赖有两种,一种是 `时间搓依赖`,还有一种是`存在依赖`.
## 时间搓依赖
在依赖之间首先会检查时间搓是否是最新的,如果不是最新的会重新触发重新构建为最新的.写法就是在
## 存在依赖
只检查依赖的资源是否存在,不检查当前依赖的资源是否是最新的.写法需要在资源前面添加一个`|`


# 变量
在make中,支持变量.将常用的内容,抽象为一个变量.在多个地方通过变量名来访问变量.最常见的是` = `,等号两边的空格存在.还有一种是` := `.通过 $(var_name)来访问.
##  = :=
两种变量赋值符号.其中带有冒号的是当前就执行变量后面的函数操作.不带冒号的是等调用的时候,才执行.
:= 这种操作类似于宏定义.在正式的通过 $(var_name)访问的时候,才会执行 := 后面的那段代码.=是在makefile文件加载的时候就会执行.

例如:
```c
A = $(B)
B = var
$(A)
```
这个$
