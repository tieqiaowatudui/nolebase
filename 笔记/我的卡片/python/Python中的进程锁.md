在python中,希望实现多个进程之间的互斥,使用文件锁.
# 使用方法
```python
from filelock import FileLock
lock = FileLock(LOCK_FILE)
with lock:
    with open(DATA_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)
    for item in data:
        if item["id"].endswith(uid):
            status = item.get("status", "todo")
            break
    else:
        raise RuntimeError("Concept not found")
```

# 实现原理
FileLock在不同平台中使用了os的特性.在linux下使用了fctl/filelock.  
实现原理和通用的锁类似.
```txt
进程试图获取锁(在内核的锁的文件登记表去登记,登记成功获得锁,登记失败表示未获取锁)
如果锁空闲就获取锁,否则就被block住,然后加入一个等待队列中.
如果锁空闲出来,就从等待队列中激活一个或多个进程获取锁.
然后继续执行.
```

锁的信息是绑定在文件的inode中的.和java中的锁存在对象头中.  
python的锁是进程之间的锁,而不是线程之间的锁.进程内部的线程之间的锁使用的是threading.lock().

# 图示

```txt
        进程A              内核锁表                     进程B
          │                    │                           │
   尝试加锁                  │                           │
   (LOCK_EX)                 │                           │
   ────────────────►         │                           │
          │                  │                           │
          │   检查：         │                           │
          │   这个范围       │                           │
          │   有没有冲突？   │                           │
          │                  │                           │
   ←──────┼─────── 是 ───────┤                           │
          │                  │                           │
          │                  │   把进程A挂到             │
          │                  │   这个锁的等待队列        │
          │                  │   (阻塞队列)              │
          │                  │                           │
          │                  ▼                           │
          │             进程A进入睡眠                  │
          │             (D状态或S状态)                 │
          │                                            │
          │                                            │  进程B也尝试加锁
          │                                            │  ────────────────►
          │                                            │           │
          │                                            │           │   检查冲突
          │                                            │   ←───────┼──── 是
          │                                            │           │
          │                                            │           ▼
          │                                            │     进程B也进入等待队列
          │                                            │
          ▼                                            ▼
    (时间继续流逝...)                           (时间继续流逝...)

稍后...
          │                                            │
   进程C释放锁 ───────────────────────────────►      │
   (LOCK_UN 或 close文件)                             │
          │                                            │
          ▼                                            │
   内核从等待队列唤醒                              │
   队首的进程(通常是先来的)                        │
   (可能是A，也可能是B，取决于调度)                │
          │                                            │
   ───────┼────────────────────────────────────────────┘
          ▼
   被唤醒的进程从 flock 调用返回
   成功获得锁，进入临界区
```



# 另外一种实现
当进程试图在内核锁文件等级失败的时候,这个shi'h


# 参考
[[Alfred插件闪念捕捉实现]]