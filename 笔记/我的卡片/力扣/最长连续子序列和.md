---
tags: [LeetCode, 算法, Python3]
aliases: []
---



## 1️⃣ 基本信息
- **题目路径**：[最长子序列和](https://leetcode.cn/problems/maximum-subarray/)
- **题目难度**： 中等 
- **标签/分类**：贪心

---

## 2️⃣ 题目描述
- **输入**：一个数组
- **输出**：其中最长子序列的和
- **样例**：

> 一个数组,求出其中最长连续子序列的和.

---

## 3️⃣ 解题思路
### 思路1（动态规划）
- 算法原理：在统计到第i个数的时候,是否需要将前面的第 i-1个数的子序列和是否>0.如果大于0,就将第i个数加入到子序列和中,否则子序列和就是第i个数的大小.
- 时间复杂度：O(n)
- 空间复杂度：O(1)

### 思路2（分治算法）
- 算法原理：数组的最长连续子序列出现在三个地方.`[left,mid]`,`[mid+1,right]`,包括mid元素的子序列
- 时间复杂度：用递归树来分析,因为是一分为二所以是 $log_2n$的高度.同时每一层的扫描的复杂度是n.所以最终的复杂度是 $nlog_2n$
- 空间复杂度：

---

## 4️⃣ Python3 技巧点
- **语法技巧**：
  - `self`python3中,在类中的方法的第一个参数是self,类似于java中隐藏的this引用.声明函数的时候,需要明确声明self这是python的设计哲学.在调用的时候不需要传递self这个参数.

---

## 5️⃣ 算法技巧点
- **算法类别**：回溯 / 动态规划 / 贪心 / 二分 / DFS / BFS / 双指针
- **常用模板**：
  - 回溯模板：
    ```python
    def backtrack(path, choices):
        if 满足条件:
            res.append(path)
            return
        for choice in choices:
            backtrack(path + [choice], choices - ...)
    ```
  - 动态规划模板：
    ```python
    dp = [0] * n
    for i in range(n):
        dp[i] = min/max/... dp[j] + ...
    ```

---

## 6️⃣ 代码实现
```python
class Solution:
    def function_name(self, params):
        # TODO: 实现代码
        pass
