---
tags: [LeetCode, 算法, Python3]
aliases: []
---



## 1️⃣ 基本信息
- **题目路径**：[有效括号](https://leetcode.cn/problems/valid-parentheses/)
- **题目难度**：简单
- **标签/分类**：栈

---

## 2️⃣ 题目描述
- **输入**：
- **输出**：
- **样例**：

> 给定一个左右括号组成的字符串.判断字符串是否是合法的括号.

---

## 3️⃣ 解题思路
### 思路1
- 算法原理：因为括号的配对是左右配对.这种配对是先出现的括号,后被配对.所以用栈来实现.
- 时间复杂度：O(n)
- 空间复杂度：O(n)


---

## 4️⃣ Python3 技巧点
- **语法技巧**：
  - 字符串可以理解为一个字符数组,所以相关的访问方式也类似.
  - 字符串每次都生成一个新字符串.由于块copy,生成字符串的子串非常高效,但是字符串拼接比较慢
- **数据结构**：
  - `stack`:最简单栈使用list实现就好.支持append() + pop()函数.如果试图获取栈顶元素而不出栈,使用 `stack[-1]`指令以获取.
  - `stack`还可以使用Collections.dequeue().这是一个双端队列.
  - dict:声明 dict语法简单. dic = {a:b,c:d}这样的语法.获取值 `dic[key]`.如果需要默认值,就是用dic.get(key,default).如果key不存在,就返回默认值.
- **常用方法**：
  - 
- **注意事项**：
  - 

---

## 5️⃣ 算法技巧点
- **算法类别**：
- **常用模板**：
  - 
---

## 6️⃣ 代码实现
### 常见解法
```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        for c in s:
            if self.is_left(c):
                stack.append(c)
            else:
                top = stack.pop()
                if not self.is_match(c,top):
                    return False
        
        if len(stack) == 0:
            return True
        else:
            return False
        
    def is_match(self,left_str: str,right_str: str) ->bool:
        if (left_str == "(" and right_str == ")" ) or \
            (left_str == "[" and right_str == "]") or \
            (left_str == "{" and right_str == "}"):
            return True
        else:
            return False
    
    def is_left(self,ch:str) -> bool:
        if ch == "(" or ch == "[" or ch == "{":
            return True
        else:
            return False
        

```



### 使用dict优化一下
判断是否是左括号和是否左右匹配,使用一个dict存放所有的括号配对.使用dict在解决这个问题上非常的高效.

```python
class Solution:
    def __init__(self):
        self.bracket ={"(":")",
                       "[":"]",
                       "{":"}"}
    def isValid(self, s: str) -> bool:
        stack = []
        for c in s:
            if c in self.bracket:
                stack.append(c)
            else:
                if len(stack) == 0 :
                    return False
                elif self.bracket[stack[-1]] != c:
                    return False
                else:
                    stack.pop()

        if len(stack) == 0:
            return True
        else:
            return False
            


```

