---
tags: [LeetCode, 算法, Python3]
aliases: []
---



## 1️⃣ 基本信息
- **题目路径**：[最小栈](https://leetcode.cn/problems/min-stack/)
- **题目难度**： 中等 
- **标签/分类**：栈
---

## 2️⃣ 题目描述
- **输入**：
- **输出**：
- **样例**：

> 设计一种数据结构,能够以O(1)的时间复杂度获取到当前栈中最小的元素。

---

## 3️⃣ 解题思路
### 思路1
- 算法原理：用一个栈记录栈中的元素,使用另外一个栈,记录当前栈中最小的元素.在栈中每一个元素是当前元素到栈底元素中的最小的元素
- 时间复杂度：O(n)
- 空间复杂度：O(n)


---

## 4️⃣ Python3 技巧点
- **语法技巧**：
  - 
- **数据结构**：
  - 
- **常用方法**：
  - 
- **注意事项**：
  - 

---

## 5️⃣ 算法技巧点
- **算法类别**：
- **常用模板**：
  - 
---

## 6️⃣ 代码实现

```python
class MinStack:
    # 最小栈,
    # 能够实现栈,同时,能够返回当前栈中的最小的元素.
    # 使用两个栈,一个用来记录元素,另外一个用来记录当前元素以及下面的所有元素最小的那个元素.
    # 出栈的时候,同时出栈

    def __init__(self):
        self.s = []
        self.ms = []
        

    def push(self, val: int) -> None:
        self.s.append(val)
        if len(self.ms) == 0:
            self.ms.append(val)
        else:
            if val < self.ms[len(self.ms) -1]:
                self.ms.append(val)
            else:
                self.ms.append(self.ms[len(self.ms) -1])


    def pop(self) -> None:
        self.ms.pop()
        return self.s.pop()
        

    def top(self) -> int:
        return self.s[len(self.s) -1]
        

    def getMin(self) -> int:
        return self.ms[len(self.ms) -1]
        


# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()
```

 