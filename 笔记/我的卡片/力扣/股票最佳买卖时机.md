---
tags: [LeetCode, 算法, Python3]
aliases: []
---



## 1️⃣ 基本信息
- **题目路径**：[股票最佳买卖时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)
- **题目难度**：简单
- **标签/分类**：数组 

---

## 2️⃣ 题目描述
- **输入**：给定一个正数数组
- **输出**：输出最高的买卖利润.
- **样例**：

> 给定一个数组,表示每一天的股票价钱.
> 然后求出一次买入和一次卖出的机会,求出最大的差值.

---

## 3️⃣ 解题思路
### 思路1（暴力/常规解法）
- 算法原理：列出所有的 (i,j)然后计算这两个数的差
- 时间复杂度：O(n^2)
- 空间复杂度：O(1)

### 思路2（优化/进阶）
- 算法原理：计算出所有相邻两个数的差.然后将所有的相邻两个数的差进行合并,然后求出最大值.
- 时间复杂度：O(n)
- 空间复杂度：O(1)
### 思路3（优化/进阶）
- 算法原理:i记录当前rank,用min_price记录`[0,rank)`之前的最小价钱,然后用`prices[rank] - min_price`计算出当前的最大收益,然后和全局最大收益进行比对.同时用 `princes[rank]`来更新`[0,rank]`区间中的min_price.
- 时间复杂度: O(n)
- 空间复杂度: O(1)

---

## 4️⃣ Python3 技巧点
- **语法技巧**：
  - range语法: range(start,end,step)默认步长是+1,如果想要倒序,这个时候step需要设置为-1

---

## 5️⃣ 算法技巧点
- **算法类别**：
---

## 6️⃣ 代码实现
### 暴力法
```python
from typing import List
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 比较两个数的最大差
        max = 0
        for i in range(len(prices)):
            for j in range(i+1,len(prices)):
                temp = prices[j] - prices[i]
                if temp > max:
                    max = temp
        return max
```

### 相邻数据差
```python
from typing import List
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 比较后面的数 - 前面的数的差.
        # 用暴力法超时.
        # 这个时候需要记录相邻两个数的差值.
        # 然后将问题转化为最大子序列和的问题.
        for i in range(len(prices)-1,0,-1):
            prices[i] = prices[i] - prices[i-1]
        max_value,temp = 0,0
        for i in range(1,len(prices)):
            temp += prices[i]
            max_value = max(temp,max_value)
            temp = max(temp,0)
        return max_value
```

### 统计当前rank之前的最低价格.
