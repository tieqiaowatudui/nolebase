---
tags: [LeetCode, 算法, Python3]
aliases: []
---



## 1️⃣ 基本信息
- **题目路径**：[翻转链表](https://leetcode.cn/problems/reverse-linked-list/)
- **题目难度**：简单
- **标签/分类**：链表
---

## 2️⃣ 题目描述
- **输入**：
- **输出**：
- **样例**：

> 给定一个链表,将这个链表进行翻转.返回翻转后的链表的位置

---

## 3️⃣ 解题思路
### 思路1（迭代）
- 算法原理：定义一个新链表头.在旧链表不为空的情况下,依次将旧链表头取下来,作为新链表的表头.最终旧链表为空,新链表表头就是翻转后的链表
- 时间复杂度：O(n)
- 空间复杂度：O(1)

### 思路2（递归）
- 算法原理：创建一个翻转后的头节点.然后用一个递归函数,包括两个元素,一个是头节点每一个是新头节点.递归结束的条件是,头节点为空,返回新节点.否则移动现有节点到新节点上去,然后继续下一轮的递归.
- 时间复杂度：O(n)
- 空间复杂度：O(n)栈上空间

---

## 4️⃣ Python3 技巧点
- **语法技巧**：

- **数据结构**：

- **常用方法**：

- **注意事项**：
 

---

## 5️⃣ 算法技巧点
- **算法类别**：
- **常用模板**：
  - 
---

## 6️⃣ 代码实现
### 迭代实现
```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 先使用迭代来实现翻转
        new_head = None
        while head is not None:
            p = head
            head = head.next
            p.next = new_head
            new_head = p
        return new_head
```

### 递归实现
```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 如何递归实现呢?
        # 如果用递归就很好实现了.
        return self.reverse(head,None)
    
    def reverse(self,head,new_head):
        if head is None :
            return new_head
        p = head
        p.next = new_head
        return self.reverse(head.next,p)
```
