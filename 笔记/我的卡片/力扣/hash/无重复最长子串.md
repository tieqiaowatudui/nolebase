---
tags: [LeetCode, 算法, Python3]
aliases: []
---



## 1️⃣ 基本信息
- **题目路径**：[无重复最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)
- **题目难度**：中等
- **标签/分类**：字符串 hash

---

## 2️⃣ 题目描述
- **输入**：
- **输出**：
- **样例**：

> 给定一个字符串,返回其中的子串中没有重复字符最长的子串长度

---

## 3️⃣ 解题思路
### 思路1（双指针）
- 算法原理：使用双指针做滑动窗口,用hash记录当前窗口中每个字符出现的次数.
- 时间复杂度：O(n)
- 空间复杂度： O(n)

### 思路2（双指针,优化点:用hash记录字符最后一次出现位置）
- 算法原理:用双指针记录当前子串的位置.用hash记录每个字符串最后一次出现的rank.只要查看每一个新加入的子串中的字符上一次出现的次数是否在子串中(index > left).这个时候就需要一定子串的左指针.
- 时间复杂度： O(n)
- 空间复杂度： O(n)

---

## 4️⃣ Python3 技巧点
- **语法技巧**：
  - 
- **数据结构**：
  - 
- **常用方法**：
  - 
- **注意事项**：
  - 

---

## 5️⃣ 算法技巧点
- 
---

## 6️⃣ 代码实现
### hash存放子串中字符出现的次数
```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # 给定一个字符串,返回这个字符串中不包括重复元素的最长子串
        # 这个使用双指针.这个区间表示一个子串.同时统计这个子串所有字符出现的次数.
        # 这里设计到遇到的元素是新元素,
        # 还有一种情况是当前元素是一个存在的元素? 这里会存在两种不同的处理方式.
        left,right = 0,0
        ch_cout = {}
        longest = 0
        while right < len(s):
            ch = s[right]
            if ch not in ch_cout or ch_cout[ch] == 0:
                ch_cout[ch] = 1
            else:
                # 有重复
                while left < right and s[left] != ch:
                    ch_cout[s[left]] -= 1
                    left += 1
                left += 1
            right += 1
            longest = max(longest,right-left)
        return longest
        

```

### 使用hash存放字符最后一次出现的位置

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # 我们用双指针指向不同元素的区间
        # 用一个hashmap记录每一个元素出现的位置
        # right出发的时候,遇到了一个元素,他的位置比 left数值的位置小,没问题.
        # 如果遇到的元素上一次出现的位置 >= left. 这个时候left的位置为[right]元素上一次出现位置 +1.这样减少计算.
        left,right = 0,0
        ch_inx = {}
        longest = 0
        while right < len(s):
            ch = s[right]
            last_idx = ch_inx.get(ch,-1)
            if last_idx < left:
                ch_inx[ch] = right
                right += 1
                longest = max(longest,right - left)
            else:
                left = last_idx+1
        return longest
```