---
tags: [LeetCode, 算法, Python3]
aliases: []
---



## 1️⃣ 基本信息
- **题目路径**：[最长子序列和](https://leetcode.cn/problems/maximum-subarray/)
- **题目难度**： 中等 
- **标签/分类**：贪心

---

## 2️⃣ 题目描述
- **输入**：一个数组
- **输出**：其中最长子序列的和
- **样例**：

> 一个数组,求出其中最长连续子序列的和.

---

## 3️⃣ 解题思路
### 思路1（动态规划）
- 算法原理：在统计到第i个数的时候,是否需要将前面的第 i-1个数的子序列和是否>0.如果大于0,就将第i个数加入到子序列和中,否则子序列和就是第i个数的大小.
- 时间复杂度：O(n)
- 空间复杂度：O(1)

### 思路2（分治算法）
- 算法原理：数组的最长连续子序列出现在三个地方.`[left,mid]`,`[mid+1,right]`,包括mid元素的子序列
- 时间复杂度：用递归树来分析,因为是一分为二所以是 $log_2n$的高度.同时每一层的扫描的复杂度是n.所以最终的复杂度是 $nlog_2n$
- 空间复杂度：

---

## 4️⃣ Python3 技巧点
- **语法技巧**：
  - `self`python3中,在类中的方法的第一个参数是self,类似于java中隐藏的this引用.声明函数的时候,需要明确声明self这是python的设计哲学.在调用的时候不需要传递self这个参数.
  - `float("-inf")`:在python3中,没有int.min_vale.而是使用float("-inf")来表示的.对于int类型,需要适用无穷小也需要适用float的无穷小.不知道底层的类型是如何实现的.后面看一下.

---

## 5️⃣ 算法技巧点

---

## 6️⃣ 代码实现
### 动态规划实现.

```python
from typing import List
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        # 给定一个数组,求最大连续数组和
        # 用 temp_sum 表示rank之前的subArray值,
        # 用 temp_sum + [rank]值,然后试图更新最大max_sub_array.
        # 如果是正就保留,否则丢弃
        max_sum,temp_sum = -float("inf"),0
        
        for value in nums:
            temp_sum += value
            max_sum = max(max_sum,temp_sum)
            temp_sum = max(temp_sum,0)
        return max_sum
        
```


### 分治实现
```python
from typing import List
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        # 使用分治算法实现.
        # 最长连续值只会出现在两个地方,一种是左边,还有一种是右边.还有这一种是两边的合并
        # 由于是分治,所以这里使用的是递归的实现方式.
        return self.divideMaxSubArray(nums,0,len(nums)-1)
    
    def divideMaxSubArray(self,nums,left,right) -> int:
        if left == right:
            return nums[left]
        mid = (left +right)//2
        return max(self.divideMaxSubArray(nums,left,mid),
                   self.divideMaxSubArray(nums,mid +1,right),
                   self.crossMidSubArray(nums,left,mid,right))

    def crossMidSubArray(self,nums,left,mid,right) -> int:
        max_sum= nums[mid]
        right_sum,max_right_sum = 0,float("-inf")
        for i in range(mid+1,right+1):
            right_sum += nums[i]
            max_right_sum = max(right_sum,max_right_sum)
        if max_right_sum >0:
            max_sum += max_right_sum
        
        left_sum,max_left_sum = 0,float("-inf")
        for i in range(mid-1,left-1,-1):
            left_sum += nums[i]
            max_left_sum = max(max_left_sum,left_sum)
        max_sum += max(max_left_sum,0)
        return max_sum
```
