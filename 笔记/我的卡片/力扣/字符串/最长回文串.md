---
tags: [LeetCode, 算法, Python3]
aliases: []
---



## 1️⃣ 基本信息
- **题目路径**：[最长回文字符串](https://leetcode.cn/problems/longest-palindrome/)
- **题目难度**：简单 
- **标签/分类**： 字符串 
---

## 2️⃣ 题目描述
- **输入**：
- **输出**：
- **样例**：

> 给定一个字符串,返回当前字符串中的字符能够构成的最大的回文字符串.

---

## 3️⃣ 解题思路
### 思路1
- 算法原理：统计出当前字符串中的所有字符出现的次数.只有一个字符能够出现奇数次,其他都只能出现偶数次.如果没有出现奇数次的字符那么就全部只能出现偶数次.
- 时间复杂度：O(n)
- 空间复杂度：O(1)



---

## 4️⃣ Python3 技巧点
- **语法技巧**：
  - 例：
- **数据结构**：
  - 
- **常用方法**：
  - 
- **注意事项**：
  - 

---

## 5️⃣ 算法技巧点
- **算法类别**：
- **常用模板**：
  - 
---

## 6️⃣ 代码实现
### 一种是%来判断是否是偶数
```python
from collections import Counter
class Solution:
    def longestPalindrome(self, s: str) -> int:
        # 能够构造出最大的回文字符串.
        # 回文字符串是偶数个字符,然后中间带一个单数的字符.
        # 统计出所有字符出现的次数.然后将所有字符出现的次数.
        # 所有的奇数都-1.然后最后+1
        c = Counter(s) 
        has_odd = False
        sum = 0
        for key,count in c.items():
            if count % 2 == 0:
                sum += count
            else:
                if not has_odd:
                    sum += count
                    has_odd = True
                else:
                    sum += count-1
        return sum
```

### 使用位运算判断是否是偶数
```python
from collections import Counter
class Solution:
    def longestPalindrome(self, s: str) -> int:
        # 使用Conter统计出所有的字符数量
        # 使用位操作进行操作
        c = Counter(s)
        sum,odd = 0,0
        for count in c.values():
            if count & 1 == 1:
                odd = 1
            sum += count & (~1)
        
        return sum + odd



```