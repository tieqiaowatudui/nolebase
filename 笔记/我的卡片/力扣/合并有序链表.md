---
tags: [LeetCode, 算法, Python3]
aliases: []
---



## 1️⃣ 基本信息
- **题目路径**：[合并有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)
- **题目难度**：简单
- **标签/分类**：链表 

---

## 2️⃣ 题目描述
- **输入**：
- **输出**：
- **样例**：

> 给定两个有序的链表.将其合并成为一个有序的连边.并且反馈链表的头节点.

---

## 3️⃣ 解题思路
### 思路1（迭代实现.）
- 算法原理：这个实现类似于归并排序的实现.为了简化代码的实现,创建一个`头结点`
- 时间复杂度：O(n+m)
- 空间复杂度：O(1)

### 思路2（递归）
- 算法原理：当前反馈的是:l1和l2归并后的结果.上层使用末尾节点的.next指向当前归并后的节点.`这种实现在树算法里非常的多`
- 时间复杂度：O(n+m)
- 空间复杂度：O(n+m)

---

## 4️⃣ Python3 技巧点
- **语法技巧**：
  -
- **数据结构**：

- **常用方法**：
  
- **注意事项**：
  

---

## 5️⃣ 算法技巧点
- **算法类别**：
---

## 6️⃣ 代码实现
### 迭代实现
```python
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        # 将两个有序链表合并.
        # 适用一个指针表示头指针,一个是尾指针.
        head = ListNode()
        tail = head
        while list1 is not None or list2 is not None:
            if list2 is None:
                tail.next = list1
                break
            elif list1 is None:
                tail.next = list2
                break
            else:
                if list1.val < list2.val:
                    tail.next = list1
                    tail = tail.next
                    list1 = list1.next
                else:
                    tail.next = list2
                    tail = list2
                    list2 = list2.next
        return head.next
        
```


### 递归实现

```python
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        # 两个链表合并.如果用递归来实现.
        if list1 is None:
            return list2
        elif list2 is None:
            return list1
        else:
            if list1.val < list2.val:
                list1.next = self.mergeTwoLists(list1.next,list2)
                return list1
            else:
                list2.next = self.mergeTwoLists(list1,list2.next)
                return list2
  
```

在递归算法设计的时候,我们的视角是当前层次,不需要考虑当前层次与高层次之间的关系,只需要考虑当前层次和