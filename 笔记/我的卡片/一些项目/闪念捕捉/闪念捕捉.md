在工作和学习的时候,发现一些概念需要深入的了解一下,但是没有办法放下当前工作,进入新的任务.这个时候需要一个快速的将概念记录下来.后续对概念进行处理,处理完成后将将概念标记为完成.  
# 交互
整体交互过程分为:  
- 记录闪念
- 列出未完成的闪念
- 处理闪念
- 标记完成的闪念
- 列出完成的闪念
# 交互实现
使用mac电脑上的Alfred Workflow来帮助实现整个流程.使用hot-key + run script / script filter + notification 帮助串起整个流程.
![[Pasted image 20260111154240.png]]
其中 Script Filter + Run Script相同的地方,都是可以接受参数,并且执行脚本.在当前任务的区别中,Script Filter可以将执行完成后的结果以列表的形式输出,然后展示在Alfred 窗口中.提供选择.Script Filter提供了一个交互的场景.Run Script的功能主要是执行一个参数.更详细的查看[[Alfred 中 Run Script和Script Filter的区别]]
# 后端实现
## 数据存储
使用两个json文件,json文件结构是一个对象的列表.一个json文件存放为处理,另一个存放处理完成的.  
列表中的每一个元素表示一个概念,概念结构如下图:
```json
{
    "id": "20260111151530",
    "title": "结构化思维和系统化思维",
    "created_at": "2026-01-11 15:15:30",
    "status": "todo",
    "done_at": null
  }
```
其中status有三种状态分别为:
- todo :未处理
- processing:处理中
- done:处理完成
## 接口函数
- done.py    :标记任务完成.
- load_done.py:加载所有完成的概念
- processing.py:处理当前的概念
- capture.py	:捕捉当前的概念			  
- load.py     :加载所有未完成的概念
- router.py:在未完成的概念列表中,选中一个概念的时候,路由到 done 或者 processing中.

## 具体实现
### capture.py
```python
# capture.py
import json
import sys
from pathlib import Path
from datetime import datetime
from filelock import FileLock

DATA_FILE = Path.home() / "Documents/concepts.json"
LOCK_FILE = str(DATA_FILE) + ".lock"

def load_data():
    if DATA_FILE.exists():
        with open(DATA_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    return []

def save_data(data):
    with open(DATA_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

def main():
    title = sys.argv[1].strip()
    if not title:
        return

    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    concept_id = datetime.now().strftime("%Y%m%d%H%M%S")

    concept = {
        "id": concept_id,
        "title": title,
        "created_at": now,
        "status": "todo",
        "done_at": None
    }

    # 文件锁，保证并发安全
    lock = FileLock(LOCK_FILE)
    with lock:
        data = load_data()
        data.append(concept)
        save_data(data)

if __name__ == "__main__":
    main()

```

### load.py
```python
import json
from pathlib import Path
from datetime import datetime

DATA_FILE = Path.home() / "Documents" / "concepts.json"

def load_data():
    if not DATA_FILE.exists():
        return []
    with open(DATA_FILE, "r", encoding="utf-8") as f:
        return json.load(f)

def main():
    data = load_data()

    todos = [c for c in data if c["status"] != "done"]
    todos.sort(key=lambda x: x["created_at"])

    items = []
    for c in todos:
        items.append({
            "uid": c["id"],
            "title": c["title"],
            "subtitle": f"Added: {c['created_at']}",
            "arg": c["id"]
        })

    print(json.dumps({"items": items}, ensure_ascii=False))

if __name__ == "__main__":
    main()

```

### router.py
```python
import json
import sys
from pathlib import Path
from filelock import FileLock

DATA_FILE = Path.home() / "Documents/concepts.json"
LOCK_FILE = str(DATA_FILE) + ".lock"

uid = sys.argv[1]

lock = FileLock(LOCK_FILE)

with lock:
    with open(DATA_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)

    for item in data:
        if item["id"].endswith(uid):
            status = item.get("status", "todo")
            break
    else:
        raise RuntimeError("Concept not found")

# ⚠️ 只做一次判断，只生成一次 arg
if status == "todo":
    print(f"processing:{uid}")
elif status == "processing":
    print(f"done:{uid}")
else:
    # done 或其他状态，不再流转
    print(f"noop:{uid}")

```

### processing.py
```python
# processing.py
import json
from pathlib import Path
from filelock import FileLock
import sys
import subprocess  # 用 pbcopy 写入剪切板

DATA_FILE = Path.home() / "Documents/concepts.json"
LOCK_FILE = str(DATA_FILE) + ".lock"

def load_data():
    if DATA_FILE.exists():
        with open(DATA_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    return []

def save_data(data):
    with open(DATA_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

def generate_processing_prompt(title: str) -> str:
    """
    根据 title 生成处理模板
    """
    template = f"""
你是一个知识解释专家。我希望你帮助我理解一个复杂的概念，请按照以下要求输出：

1. **概念名称**：<在这里写你想理解的概念>
2. **分级解释**：
   - **入门版**：用最简单的语言和生活类比解释，适合完全不了解的人。
   - **标准版**：用一般学术或专业语言解释，适合有基础知识的人。
   - **深度版**：详细原理、机制、理论或公式说明，适合专业人士。
3. **多角度展示**：
   - **文字解释**：清楚、易懂的文字描述。
   - **图示/类比**：如果可以，用示意图、流程图或类比加深理解。
   - **问答形式**：列出3-5个常见问题及答案，帮助记忆。
4. **总结与关键点**：
   - 列出核心要点，最多10条，便于快速回顾或制作记忆卡片。
   请按照这个结构输出内容，每一层和每个角度都清楚标注标题。
概念名称：{title}
"""
    return template

def process_concept(concept_id: str):
    """
    处理单个概念：
    1. 使用 title 拼接模板
    2. 写入剪切板
    3. 修改状态为 processing
    """
    lock = FileLock(LOCK_FILE)
    with lock:
        data = load_data()
        concept = next((c for c in data if c["id"] == concept_id), None)
        if not concept:
            print(f"对象 {concept_id} 不存在")
            return

        title = concept["title"]

        # 拼装模板
        final_text = generate_processing_prompt(title)

        # 写入剪切板（macOS pbcopy）
        subprocess.run("pbcopy", input=final_text.encode(), check=True)
        print(f"已将 '{title}' 的处理文本写入剪切板")

        # 修改状态
        concept["status"] = "processing"
        save_data(data)
        print(f"对象 {concept_id} 状态已修改为 processing")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("请提供 concept_id")
        sys.exit(1)
    info = sys.argv[1].strip()
    action,id = info.split(":",1)
    process_concept(id)

```

### done.py
```python
import json
import sys
from pathlib import Path
from datetime import datetime
from filelock import FileLock

DATA_FILE = Path.home() / "Documents" / "concepts.json"
DATA_DONE_FILE = Path.home() / "Documents" / "concepts_done.json"
LOCK_FILE = str(DATA_FILE) + ".lock"

def load_data(file_path):
    if not file_path.exists():
        return []
    with open(file_path, "r", encoding="utf-8") as f:
        return json.load(f)

def save_data(data, file_path):
    with open(file_path, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

def main():
    action, concept_id = sys.argv[1].strip().split(":", 1)
    if not concept_id:
        return

    lock = FileLock(LOCK_FILE)
    with lock:
        # 1. 从主文件中加载数据
        main_data = load_data(DATA_FILE)

        # 2. 找到目标概念
        concept_to_move = None
        for c in main_data:
            if c["id"].endswith(concept_id):
                concept_to_move = c
                break
        
        if concept_to_move:
            # 3. 从主列表中移除
            main_data.remove(concept_to_move)
            save_data(main_data, DATA_FILE)

            # 4. 更新状态并添加到 done 文件
            now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            concept_to_move["status"] = "done"
            concept_to_move["done_at"] = now
            print(concept_to_move["title"])

            done_data = load_data(DATA_DONE_FILE)
            done_data.append(concept_to_move)
            save_data(done_data, DATA_DONE_FILE)

if __name__ == "__main__":
    main()

```

### load_done.py
```python
import json
from pathlib import Path
from datetime import datetime

DATA_DONE_FILE = Path.home() / "Documents" / "concepts_done.json"

def load_data(file_path):
    if not file_path.exists():
        return []
    with open(file_path, "r", encoding="utf-8") as f:
        return json.load(f)

def main():
    data = load_data(DATA_DONE_FILE)

    # Sort by done_at if available, otherwise by created_at. Display newest done first.
    data.sort(key=lambda x: x.get("done_at", x["created_at"]), reverse=True)

    items = []
    for c in data:
        done_at_str = c.get("done_at", "N/A")
        items.append({
            "uid": c["id"],
            "title": c["title"],
            "subtitle": f"Done: {done_at_str}",
            "arg": c["id"]
        })

    print(json.dumps({"items": items}, ensure_ascii=False))

if __name__ == "__main__":
    main()

```

# 开发过程
## 遇到的bug
由于Alfred中不能指定python的路径,这里只能默认的是 /usr/bin/python.在一些mac下,这里的python是默认的python2,所以只能使用  bash指令来完成指定python3的操作.
`/usr/local/bin/python3.12 capture.py "{query}"`以上

## 自动化开发
使用chatgpt或者cursor的开发能够有效的降低开发的复杂度.有效的提升系统的