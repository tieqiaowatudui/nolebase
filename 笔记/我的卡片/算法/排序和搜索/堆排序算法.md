插入排序算法是从一个待排序数组中,不断选出其中最小的元素,移动到已经排序数组的最后面.插入排序是前面有序,后面无序,逐步变成全局有序的转变.
由于插入排序的时间复杂度是O(n^2),是一种效率较低的算法.所以做了优化没到局部有序,只有在获取最小和插入消耗较小,同时在时间复杂度变为O($log_2n$)的排序.
# 堆的结构
堆分为大根堆和小根堆.其中:
- 父节点最大是大根堆
- 父节点最小是小根堆
堆使用了数组的方式来存放所有的数据.这样能够有效的提升空间使用效率.整个序列从数组的1开始存放.任意一个节点i,其父节点和左右孩子节点的位置为:
```python
# 这个堆的 root节点rank = 1 不是从0开始.
# 如果是从0 开始  
#      l_child = i * 2 +1
#      r_child = i * 2 + 2
#      parent = (i-1) // 2
def parent(i) -> int:
	return i //2

def left_child(i) -> int:
	return i * 2	

def right_child(i) -> int:
	return i * 2 + 1

```
这里确定了任意一个节点i他的左右子树的节点都比 i节点大或者小.
因为使用了数组来存放整个堆,而堆的结构是一个完全二叉树的结构,优点是提升了空间使用效率.缺点是:当插入新节点的时候需要移动大量的数据.

# 构建堆
> 将新数写入到堆的最后的位置,然后一路往上爬,这和冒泡排序有点类似
将新插入的数据,写到堆最后的位置,然后计算出parent节点的位置,然后进行比较.如果小于就交换当前节点和parent节点的位置.然后一路比较上去.

# 提取最小元素
堆中的最小元素在堆顶,我们需要做的事情是将堆顶的元素取出,然后用堆最后的元素存放在堆顶.这样会导致堆结构失效.这个时候就需要调整对的结构.
这个过程是一个下沉的过程.就是比较堆顶的元素和两个子孩子中更小的元素,然后选择