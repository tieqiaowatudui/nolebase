插入排序算法是从一个待排序数组中,不断选出其中最小的元素,移动到已经排序数组的最后面.插入排序是前面有序,后面无序,逐步变成全局有序的转变.
由于插入排序的时间复杂度是O(n^2),是一种效率较低的算法.所以做了优化没到局部有序,只有在获取最小和插入消耗较小,同时在时间复杂度变为O($log_2n$)的排序.
# 堆的结构
堆分为大根堆和小根堆.其中:
- 父节点最大是大根堆
- 父节点最小是小根堆
堆使用了数组的方式来存放所有的数据.这样能够有效的提升空间使用效率.整个序列从数组的1开始存放.任意一个节点i,其父节点和左右孩子节点的位置为:
```python
# 这个堆的 root节点rank = 1 不是从0开始.
# 如果是从0 开始  
#      l_child = i * 2 +1
#      r_child = i * 2 + 2
#      parent = (i-1) // 2
def parent(i) -> int:
	return i //2

def left_child(i) -> int:
	return i * 2	

def right_child(i) -> int:
	return i * 2 + 1

```
这里确定了任意一个节点i他的左右子树的节点都比 i节点大或者小.
因为使用了数组来存放整个堆,而堆的结构是一个完全二叉树的结构,优点是提升了空间使用效率.缺点是:当插入新节点的时候需要移动大量的数据.

# 构建堆
> 将新数写入到堆的最后的位置,然后一路往上爬,这和冒泡排序有点类似
将新插入的数据,写到堆最后的位置,然后计算出parent节点的位置,然后进行比较.如果小于就交换当前节点和parent节点的位置.然后一路比较上去.

# 提取最小元素
堆中的最小元素在堆顶,我们需要做的事情是将堆顶的元素取出,然后用堆最后的元素存放在堆顶.这样会导致堆结构失效.这个时候就需要调整对的结构.
这个过程是一个下沉的过程.就是比较堆顶的元素和两个子孩子中更小的元素,然后选择交换值,然后继续进行下沉.直到下沉到最后.
下沉的过程是一个递归的过程,因为任何一个位置的节点都可以看成是一个子堆的根.这样就能够不断地下沉了.
堆排的实现就是通过[[#提取最小元素]]实现的,就是不断的将堆顶的元素取出来,然后用堆最后的元素替换,然后信息下沉.最终在原地实现排序.
# 建堆过程的优化
我们正常的方式是自顶向下的建堆,不断的将元素加入到堆的最后一个元素中然后对堆进行bubble_up这样不断的建成一个堆.这里时间复杂度是 O(nlogn).
还有一种是自底向上,假设已知了所有的元素,然后将所有元素添加到数组中,其中后一半`[n//2,n-1]`这一半是叶子节点不需要进行bubble_down.值需要对`[0,n//2-1]`这些元素进行bubble_down.就可以完成了整个树的构建.
由于 1/2不需要下沉,1/4只需要一次下沉,....只有一个需要$log_2n$次下沉.最终的和是 O(n)
这种自底向上的建堆的前提是堆中的元素是确定的,但是很多时候堆中的元素是不断的添加和删除,所以最差的堆排序还是O(n$log_2n$)
# 如何确定堆中第k大的元素是否小于等于 x
这种实现可以用递归来实现,优先访问左子树,然后访问右子树.
```python
def heap_compare(self,heap,idx,count ,x)--> int:
	if count <= 0 || idx >= len(heap):
		return count
	if head[idx] <= x:
		count = self.heap_compare(heap,self.l_child(idx),count-1,x)
		count = self.head_compare(head,self.r_child(idx),count,x)
	return count
```

> 上面这个算法count初始是k,表示不小于等于x的元素剩余k个.然后依次从根开始进行比较下去遇到了 count <= 0 表示满足了要求,如果堆结束了就返回对应的元素.


### **4.3.5 通过增量插入实现排序**

现在来考虑一种基于高效数据结构的不同排序方法。  
从未排序集合中选取任意一个元素，并把它放到已排序集合中的合适位置。
```c
InsertionSort(A)     
	A[0] = -∞     
	for i = 2 to n do         
		j = i         
		while (A[j] < A[j - 1]) do             
			swap(A[j], A[j - 1])             
			j = j - 1
```


插入排序的 C 语言实现曾在第 2.5.2 节（第 43 页）出现过。  
尽管插入排序在最坏情况下需要 O(n²) 时间，但如果数据已经接近有序，性能会好得多，因为内层循环只需要少量迭代即可将元素筛到正确的位置。

插入排序也许是“增量插入”技巧最简单的示例：  
我们先对 n−1 个元素构建好一个结构，然后进行必要的操作，将最后一个元素加入进去。

增量插入是几何算法中特别有用的一种技术。

注意，如果使用更高效的数据结构，基于增量插入的排序算法可以更快。  
例如，插入平衡二叉搜索树每次操作需要 O(log n)，构建整棵树耗时 O(n log n)。  
再进行一次中序遍历即可按排序顺序读出所有元素，这一步是线性的。

