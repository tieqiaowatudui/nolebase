排序算法是将无序的数据按照期待的降序或者升序进行排列.排序算法是我们学习得最多次数的算法.在学习编程的时候会学习,学习数据结构的时候会学,在最终的算法设计的课程中也需要学习.
排序算法也是整个算法体系中最重要的算法.一方面是排序算法被其他很多算法依赖,另一方面排序算法中也包括了其他的算法设计思想,分治,随机化等.还有排序算法在整个计算机的执行比例中占有25%的比例以上.同时排序算法也是被研究得最透彻的问题,有大量的适用于各种不同场景的排序算法被开发出来.
排序算法中最终要的指标是时间复杂度.时间复杂度分为$nlog_2n$和O(n^2).其中如果一个排序算法是O(n^2)那么这个算法在数据量很大的时候效率会非常的差.
# 排序算法的作用
排序算法真很多场景下都非常有用.例如
- 快速查找,直接用2分查找
- 找出第k个元素
- 判断是否有重复
- 找出两个元素之间的差值
- 元素出现的最多次数.
- 平面的一堆点,找出边轮廓的线.凸包问题
- ...

### 思考题:一个大,一个小的数组,求两个元素的交集
有两个数组,一个大的n,一个小的m,如何快速求出交集,我们都知道了使用排序这里有三种排序的方式:
- 排序n,然后用m进行查找
$$nlog_2n + mlog_2n$$ 等价于:$$(n+m)log_2n$$
- 排序m,然后用m进行查找
$$nlog_2n + mlog_2n$$ 等价于$$(n+m)log_2m$$
- 对n和m进行同时排序.然后依次遍历比较
$$nlog_2n + mlog_2m + (n + m)$$
以上可以看到,排序小的数组,尤其当m特别小的时候,将会退化为线性的查猪效果.

当然还有更好的查询效果,就是构建hash表.将n构建为hash表.然后用m进行查询.这里得到的时间复杂度是$$m+n$$

## **4.2 排序的实践问题**

我们已经看到排序的许多算法应用，并且也会学习几种高效的排序算法。但它们之间有一个共同的问题：**我们究竟希望按什么顺序排序？**  
这个问题的答案因应用而异。下面是一些需要考虑的方面：
### **• 升序还是降序？**
一组键 S 若满足对所有 1 ≤ i < n 都有 Si ≤ Si+1，则称为升序排序；  
若满足 Si ≥ Si+1，则称为降序排序。  
不同的应用对排序方向有不同需求。

### **• 排序仅按 key，还是对整个记录排序？**

在对数据集排序时，必须保持复杂数据记录的整体性。  
例如含有姓名、地址、电话号码的通讯录，可能按姓名排序，但记录内部的关联必须保持不变。  
因此在处理复杂记录时必须明确哪一个字段作为 key，以及理解记录的整体结构。

---

### **• 如何处理相等的 key？**

具有相同 key 的元素会在排序后聚在一起，但有时它们原本的相对顺序也很重要。  
例如百科全书中包含两个“Michael Jordan”（篮球运动员与统计学家），那应该先列哪个？  
可能需要采用次关键字（如文章长度）来有意义地区分它们。

有时要求保持原始顺序，这类排序算法称为 **稳定排序**。  
但遗憾的是，大多数快速排序算法并不是稳定的。  
任何排序算法都可以通过把“初始位置”作为次关键字来强制实现稳定性。

如果对相等 key 无要求，可以不做限制，让结果顺其自然。  
但要注意，某些高效排序算法（如 quicksort）在出现大量相等 key 时可能会退化为二次复杂度，  
除非特别为此优化过。

---

### **• 如何处理非数值型数据？**

对字符串进行排序（如字母序）时，需要非常复杂而精细的规定：  
Skiena 与 skiena 算不算同一个 key？  
Brown-Williams 与 Brown America、Brown, John 的顺序如何确定？  
这些都由应用特定的 **比较函数（comparison function）** 来定义。

比较函数接收两个记录指针 a 和 b：

- 若 a < b → 返回 “<”
    
- 若 a > b → 返回 “>”
    
- 若相等 → 返回 “=”
    

通过把比较行为抽象成比较函数，排序算法就能独立于具体的比较细节。  
只需把比较函数作为参数传给排序过程即可。

任何合理的编程语言都提供库函数实现排序，你几乎总是应该使用它，而不是自己写。

例如 C 标准库提供 qsort：

`#include <stdlib.h> void qsort(void *base, size_t nel, size_t width,            int (*compare)(const void *, const void *));`

参数说明：

- base：数组起始地址
    
- nel：要排序的元素数量
    
- width：每个元素占用的字节数  
    （因此可排序字节、整数、甚至 100 字节的结构体，只需调整 width）
    

排序的最终顺序由 compare 函数决定。  
compare 接受两个 width 字节长度的元素指针：

- 若第一个应排在前 → 返回负数
    
- 若第二个应排在前 → 返回正数
    
- 若相等 → 返回 0
    

例如升序排序整数的比较函数：
```c
int intcompare(int *i, int *j) {     
	if (*i > *j) 
		return 1;     
	if (*i < *j) 
		return -1;     
	return 0; 
}
```


调用方式：

`qsort(a, n, sizeof(int), intcompare);`

函数名 qsort 暗示其内部实现可能是快速排序，但对用户来说通常无关紧要。

