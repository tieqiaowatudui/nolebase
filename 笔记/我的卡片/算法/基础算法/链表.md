
---
type: 卡片
tags:
  - 算法
  - 2025年
  - 11月
  - 27号
  - 周4
  - 今年的第331天
date: 2025-11-27
week: 今年48周
--- 
链表也是一种序列类型另外一种实现.相比于[[数组]]需要分配一块连续的内存空间,且内存空间不能变.链表每次只有一个节点,节点之间的序列关系通过一个指针来指向下一个节点.
# 结构
链表的节点,每一个节点有一个`item`用来存放数据,用一个`*next`来指向像一个节点的位置.
```c
typedef struct list {
    item_type item;      // 正经货，真金白银要存的东西
    struct list *next;   // 下一个傻兄弟在哪儿
} list;
```
但多个链表节点连接在一起组成一个链表的时候,示意图如下:

```lua
+-----------+-------+     +-----------+-------+     +----------+--------+
|  Lincoln  |   *---+---->| Jefferson |   *---+---->|  Clinton  |  NIL  |
+-----------+-------+     +-----------+-------+     +----------+--------+
```


# 操作

## 查询值(搜索)
从头节点开始,依次遍历,如果当前节点为nill说明链表为空,直接返回nil,表示没有查询到;
如果当前节点的值等于待搜索的值x,那么就返回当前节点的值,
否则就从当前节点的下一个节点继续去寻找.

```c
list * serach_list(list *l,item_type x)
{
	if(l == NULL)
		return NULL;
	if(l -> item == x)
		return l;
	else
		search_list(l -> next,x);
}
```
这里使用了递归的方式来实现,事实上也可以用迭代的方式来实现.用递归的方式时间显得更加简洁.

## 插入元素
在链表头部插入元素.由于插入在链表头,所以使用的是指针的指针的形式传递.
```c
void insert(list **l , item_type x)
{
	list* p;
	p = malloc(sizeof(list));
	p -> item = x;
	p -> next = *l;
	*l = p; 
}
```

因为这里需要修改头节点的指针.所以这里传递的参数是 `**l`.
同时最后一行给头指针赋予新值的时候,需要使用`*l = p`.这样修改调用函数中的头指针的内容.

## 删除元素
删除元素首先查找当前节点是否存在,如果不存在直接返回.如果存在,寻找到待删除节点的前一个节点,然后删除.由于可能的情况是带删除的节点是头节点.这个时候需要修改头节点.
```c
void delete(list **l , item_type x)
{
	list* node = search(*l,x);
	if(node == null)
		return;
	list *p = *l;
	list * pre = NULL;
	while(p -> next != null && p -> next -> item != x){
		pre = p;
		p = p -> next;
	}
	if(pre == null){
		*l = p -> next;
	}else{
		pre -> next = p -> next;
	}
	free(p);
}
```





# 性能


# 概念


