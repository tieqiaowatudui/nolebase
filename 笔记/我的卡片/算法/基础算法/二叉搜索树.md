
---
type: 卡片
tags:
  - 算法
  - 2025年
  - 11月
  - 27号
  - 周4
  - 今年的第331天
date: 2025-11-27
week: 今年48周
--- 
我们在之前的[[字典]]的实现里,使用了序列类型的数据结构[[数组]]和[[链表]]这两种实现方式.这两种实现方式在某些场景下表现很好,但是在很多场景下表现却很差.
现在有一种新的数据结构,二叉搜索树,这是一种遵守特殊规则的二叉树.
对于任意一个节点,左子树上的只小于当前节点,右子树的值都大于当前节点.
这种结构中任何一颗子树都满足最小节点是最左边的节点,最大节点是最右的节点.
# 结构
树是由一个个节点组成.其中每一个节点由一个值+三个指针组成.这三个指针分别是左右子树指针和父节点指针.
在标准的二叉搜索树中是没有指向父节点的指针的,但是在之前的[[字典]]的实现中,操作中有前驱后继节点的功能,所以需要添加指向父节点的指针.一种空间换时间的权衡.

```c
typedef struct tree_node{
	item_type value;
	tree_node *left;
	tree_node *right;
	tree_node *parent;
}tree_node;
```
效果如下图
![[Pasted image 20251128151254.png]]
# 操作
当多个`tree_node`组成了二叉搜索树,需要提供的操作有:
```c
void insert(tree_node `*root` ,item_type key);
item_type search(tree_node `*root`,item_type key);
tree_node * delete(tree_node `*root`,item_type key);
tree_node * min(tree_node `*root`);
tree_node* max(tree_node `*root`);
tree_node* successor(tree_node `*root`,item_type key);
tree_node* precursor(tree_node `*root`,item_type key);
void traverse_tree(tree_node `*root`);
```
# 性能
因为二叉搜索树是二叉树,任意的查询,插入和最大最小的复杂度主要是定位的复杂度.其中定位消耗的时间就是树的高度.O(h).
但是树的高度会受到插入的顺序影响.如果插入的顺序就是有序的,那么会导致整个二叉搜索树的退化为一个链表.这样树的高度就从 O(h)变为了O(n).
对于这种有序插入导致的性能退化,使用随机化插入.ku


# 概念


