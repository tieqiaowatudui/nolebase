
---
type: 卡片
tags:
  - 算法
  - 2025年
  - 11月
  - 27号
  - 周4
  - 今年的第331天
date: 2025-11-27
week: 今年48周
--- 

# 结构
hash表是一种call-by-key的数据结构.就是给定一个值key只要通过时间复杂度为1的获取到key对应的值.具体来说过程就是通过key计算出一个整数,然后用这个整数去数组的对应下标的空间中去获取值,这样只要时间复杂度为1的查询效率.

### 如何计算hash?
使用一个基数α(能够包括key中所有可能的字符的空间值.),然后计算α进制的数来表示字符串.例如abc.就可以表示为 `a*26^2+b*26+c`,这样就得到一个唯一的数值来表示下标.这个数值在理论上是唯一的,但在工程上这个数值会非常的大,那么就没有办法表示这么大的数值,这个时候就会取一个空间M,然后用得到的hash只mod这个M.这样就会导致多个key落到了同一个下标的空间中,这种情况就被称为冲突.

### 如何解决冲突
当同一个下标中出现多个key的时候,这个时候就是冲突了.这个时候就需要解冲突.解冲突的方式有两种,一种是**链地址法**,另一种是**开放地址法**.
开链地址法是每个人搬个小板凳坐后面排队.实现方式是,真个hash表示链表的数组,每当一个下标中有一个元素进入,就往后面挂一个,这样就解决了冲突.开链地址法的优点是更新比较快.缺点是额外消耗空间,且局部性不好.最差的情况是所有的元素都落到同一个下标下面,这样访问退化成为了链表访问.
开放地址法就是地方就这么打,不行就挤挤.实现方式是:当写入的时候发现对应位置上已经有元素了,这个时候就向后依次查看,直到有空的位置,将对应的元素添加进去.优点是:局部性好,缺点是,在删除的时候需要把当前坐标后面所有的元素都需要站起来重新计算并写入一遍.


# hash的应用场景
## 快速查找字符串出现的位置(Rabin-Karp算法)
我们在用一个字符串进行全局搜索,正常的做法是依次比较.时间复杂度为`O(n*m)`,这种是最差的方法.非常的耗时间.
如果用hash就快很多了.对于前m个元素,老实计算对应的hash,后面的n-m+1个元素,只需要去除最高位的值,加上最低位的值就能生成新的hash值,这样就能够实现了O(n)的复杂度进行全局搜索.
对于这种算法可以优化的地方是,hash值可以不是唯一的.增加一步冲突的时候再次比对,也能进行优化效率.

## hash还能够查询数据是否被修改过
很多时候,我们投标的时候,为了防止金额被修改过,要求在投标之前,先将对应的金额数据对应的hash值发送给招标方,然后在投标以后,将所有人的金额和实现金额对应的hash进行比对,以确定是否修改了标的金额.

## hash能够实现论文查重
将论文库中所有的字符以50或者100位一组,然后将这些字符串生成一个hash值存放在数据库里.
然后输入一个待查重的论文,依次生成50个字符的hash值,然后进入数据库里查询,如果查询到就是重复了.
## hash能够判定论文是否修改
为每一个论文生成一个hash值,这个值作为指纹.然后查询一篇论文生成对应的hash值和旧的hash值进行比较,如果变化了就是修改过了.


# hash值工程上的实现
在理论上,只要α值选择包括了key的所有字符空间


