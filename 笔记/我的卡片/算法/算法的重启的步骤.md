# 目标
应付算法面试题
掌握如何学习一个算法的方法
掌握如何设计一个算法的方法

# 步骤
```mermaid
flowchart LR
问题 --> 思维 --> 技巧 --> 题目 --> 体系
```

# 第一层:建立算法思维
# 第二层 如何掌握一个算法
## 数据结构映射
- 快速查找 -  hash表
- 先进先出 - 队列
- 维护最值 - 堆
## 分解为子问题(divide&conquer)
- 核心:大问题 = 小问题的组合
- 典型应用:归并排序 ,快速排序,二分查找
- 关键问题:"如何将大问题分解为相互独立的小问题"
## 状态与决策(Dynamic Programing)
- 记录过去,影响未来
- 典型应用:背包,最长子序列,路径问题
- 关键问题:"当前决策依赖哪些历史信息?"
## 约束剪枝(Backtracking)
- 核心:试错 + 及早放弃
- 典型应用:排列组合,N皇后,数独
- 关键问题:"什么时候可以判断当前路径可以放弃?"
## 排序/二分(Optimization)
- 是否可以通过排序和二分快速查找/跳过
- 典型应用:查找,区间问题,去重
- 关键问题:"排序后,能够利用什么特性?"除了有序以后,还有一个是相同的元素会在一起
## 图抽象(Graph Thinking)
- 万物都可设计为状态+联系
- 典型应用:最短路径,拓扑排序,连通量
- 关键问题:"实体之间有什么联系"
## 贪心思维(Greedy Thinking)
- 局部最优解是否能够导出全局最优的解
- 典型应用:区间调度 , 霍夫曼编码
- 关键问题:"每一步选择当前最优的,最终全局的结果是否是最优的"
[算法的通用思维](https://claude.ai/chat/f18c0f97-0481-4ffd-8f14-c351b710dfa3)
## 如何掌握一个算法
遇到一个陌生算法,学习并掌握这个算法的方法有一个基本套路:
```mermaid
flowchart LR
问题分类 --> 算法思想 --> 如何保证正确性 --> 如何实现
```

## 算法分类
算法绝大多数可以分为8类:
```c
1.搜索(DFS/BFS)
2.动态规划(DP)
3.贪心算法(Greedy)
4.排序/二分
5.并查集/集合
6.图算法(Graph)
7.字符串算法(KMP,Trie)
8.数学,几何
```

## 算法思想
确定当前算法的主要设计思想.
[如何确定算法思想](https://claude.ai/chat/ce2bffbc-27a1-4195-9c99-71e30eb3b3a3)
步骤如下:
### 1.查看算法的输入和输出
- 查看算法的输入和输出
- 比对输入和输出的差异.
- 例如:将无序的数组变成有序的数组,在不确定位置的数据堆中找出元素的位置
### 2.用一个小的例子跑算法确定关键变量的变化以及每一步的决策
- 用一个小例子来跑整个算法的流程
- 查看算法中的关键变量的状态及其变化
- 查看状态在每一步变化的时候是如何决策的
- 快速排序,其中的pivot是如何变化的,如何将整个数组分割开来的.
### 3.其中的关键问题
- 问题如何分解
```c
1.大问题如何分解为更小的问题的?
2.小问题之间的关系是什么?(独立,重叠)
3.小问题的答案如何合并
```
- 效率优化
```c
1.如何避免暴力解法?
2.如何避免计算重复的实现?
3.用哪些数据结构能提升查询和存储?
```
- 策略选择?
```c
1.每一步骤的决策是什么?
2.当前决策是否可以剪枝跳过?
3.当前决策是否可以用贪心算法?还是考虑全局的结果?
```
### 4.识别当前算法属于的类别

| 思维名称 | 核心特征                      | 典型问题          |
| ---- | ------------------------- | ------------- |
| 分治   | 分解--> 独立求解--> 合并          | 快速排序,归并排序     |
| 动态规划 | 分解 --> 存储中间结果,避免重复 --> 递推 | 背包问题,最长子序列    |
| 贪心   | 分解 --> 每一步最优              | 霍夫曼编码 , 最小生成树 |
| 回溯   | 尝试 --> 失败后退               | dfs,数独,n皇后问题  |
| 双指针  | 两端或者快慢指针                  | 链表环,两数之和      |
| 滑动窗口 | 维护区间动态调整                  | 最小子串,最小覆盖     |
###  5.提炼Idea的方法
当前算法通过{做什么}实现了{某种目标}
例如:
- 快速排序,通过选择pivot的位置,将小的元素在左边,大的元素在右边,递归实现排序
- Dijkstra算法,通过贪心选择最近的节点,并更新邻居距离,最终逐步确定最短路径.
- KMP算法:通过预处理模式串的next数组,避免匹配失败时,回退得更多.


### 6.检验是否掌握了算法思想
- 用自己的话回复当前算法的思想?
- 这个算法相比暴力法哪些地方进行了优化?
- 这个算法的适用场景?


## 证明算法正确性
[算法正确性证明](https://claude.ai/chat/504b788e-53f2-43c0-989e-297e995deb77)
算法的完全正确包括两部分.
> 完全正确 = 算法局部正确 + 算法终止

对于算法的局部正确,那么设计到了三种方法.
### 循环不变形(迭代)
当算法用迭代的方式写的,这个时候需要通过算法循环不变性来证明.
- 初始化:在开始的时候,算法符合约定,
- 维护:算法中间的任何一步执行的时候,也满足约定
- 终止:算法结束的时候,依然满足约定
步骤如下:
```c
1.定义循环不变式 P
2.初始化:循环的初始条件的时候,P满足
3.维护:对于其中任意一步k,在执行逻辑之前满足不变式P,在执行完成以后依然完成不变式P
4.终止:算法能够结束 + 不变式P依然成立
```


### 归纳法(递归)
递归的正确性是标准的归纳法来实现.
步骤如下:
```c
1.基础情况:证明最小规模输入(如n=0,n=1)正确
2.归纳假设:假设在k < n的情况下,所有的情况都正确
3.归纳步骤:证明在k = n的时候算法正确
```


### 前置条件后置条件论证法(通用验证法)
算法前后,整个变量满足一些条件,通过算法执行满足条件.
步骤如下:
```c
1.确定算法的前置条件P和后置条件Q
2.当前变量满足前置条件P
3.执行算法
3.执行完成后满足后置条件 Q
```

### 反证法
在论证一些算法的最优性的场景下,使用反证法.(尤其是贪心算法的最优性)
步骤如下:
```c
1.假设存在一种比贪心算法更优秀的算法 S*
2.通过"交换论证"的方式,就是在S*算法中的选择依然使用贪心算法的选择.得到的算法并不会比贪心算法更优秀
3.得出结论,S*算法并不比贪心算法更加优秀.
```

## 通用算法的正确性
### 1.定义规格说明
```c
1.输入的变量,以及这些变量的限制
2.输出的结果,以及这些输出存在的限制
3.前置条件:整个输入应该满足哪些条件
3.后置条件:输出结果应该满足哪些约束?
```

### 2.证明部分正确性
```c
1.迭代:循环不变性
2.递归:数学归纳法
3.贪心:反证法 + 交换论证
```

### 3.证明终止性
```c
1.迭代:循环单调有界性
2.递归:问题规模严格减小
3.良性问题:问题规模不是无限的
```

### 4.特殊边界查看
```c
1.空区间
2.只有一个元素
3.最大/小元素
4.重复元素
```

## 写完算法正确性检查的步骤

### 完备性(不漏)
- 所有可能输入是否被覆盖了?
- 边界条件是否考虑到了?
- 递归/状态空间是否都访问到了?
### 互斥性(不重)
- 是否同一个解计算了多次
- 是否有去重机制?
- 解空间是否进入了多次
### 最优性检查(反证法 + 交换论证)
- 当前的解法是否确定选择是最优的?
- 当前的转移方程是否包括了所有的解空间?
- 是否有反例来证明当前的结果不是最优的?

### 终止性检查(算法能够结束)
- 循环变量会收敛吗?
- 递归的深度是有限的吗?
- 是否有死循环?





## 如何写一个算法
[如何写一个算法](https://claude.ai/chat/7b72929e-7219-4410-b26b-52a3206d2994)
### 实现步骤
```c
1.理解问题和设计算法 --> 20%
2.写伪代码          
3.trace代码,至少使用三个例子  --> 30% 最重要
4.写代码  --> 30%
5.自己查看代码查看边界条件(空值,单值,最值)  --> 20%
```


### 常见问题
```c
1.直接写代码,没有写伪代码
2.没有trace代码.
3.只trace了正常的逻辑,没有查看边界case
4.太早的优化
```


# 如何设计一个算法
[如何设计一个算法](https://claude.ai/chat/8a7a85f7-39e6-443d-ae08-18c93e1b918e)
在数学上,设计算法是一个严谨的过程.
但是在工程上,最重要的是选择一个可以使用的算法来解决问题.
根据遇到问题的一些特征,然后确定激活那一部分算法的特征,然后用这些算法的特征来解决问题.
有几个决策点:包括,是否图,子问题,子问题是否独立,子问题是否重复,以及子问题的解空间是否可以提前跳过的,以及解的问题是否是单调有序的.
通过这些决策点选择对应的算法.
## 决策点
### 1.是否可以建模为图
```c
关键词:状态,链接,依赖,网络
结构:节点之间有关系
问题:遍历,连通性,最短路径等

例子:
课程依赖关系:拓扑排序
岛屿数量:图遍历
最短路径:Dijkstra/BFS
```

### 递归决策点2~4
```c
			能定义子问题？
                 ↓
        ┌────────┴────────┐
       YES               NO
        ↓                 ↓
   子问题独立？         模拟/贪心
        ↓
   ┌────┴────┐
  YES       NO
   ↓         ↓
  分治    有重复？
           ↓
      ┌────┴────┐
     YES       NO
      ↓         ↓
     DP      普通递归
```

### 决策点5:发现了单调性
```c
发现单调性
    ↓
┌───┴───┬────────┬─────────┐
↓       ↓        ↓         ↓
二分    双指针   滑动窗口  单调栈/队列

例子：
- 有序数组查找 → 二分
- 两数之和（有序）→ 双指针
- 固定大小窗口最值 → 单调队列
- 下一个更大元素 → 单调栈
```

### 决策点6:贪心
```c
问题有"最优子结构"
局部最优选择不影响后续的选择
可以用"交换论证"和"反证法"

经典贪心算法:
区域调度 --> 安结束时间排序
跳跃游戏 --> 每次跳跃最远
分配问题 --> 优先满足小的

```

### 决策点7:剪枝+时间压缩
```c
当前解空间中,有能够不需要访问的路径.
使用剪枝的方法,跳过解空间.

经典算法:

```